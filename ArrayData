Array Program
===============
//print array element
//find maximun/minimum number from array
//find duplicate element from array
//find second largest element from array
//frequency of array element
//find 1st repeated element / non repeated element from array
// find index of nonrepeated element
//sum and multiplication of array element
//sort array element
//reverse of array element
//check two array are equal or not
//java program to merge two array
//find binary number from array
// sort by char in list
//2 list string remove distinct
//divisible by 2 and multiply by 3
//squ of elements and sum
//n>10 and average
TreeMap1: {1=10, 2=20, 3=30}
TreeMap2: {2=15, 3=25, 4=40}
Output: {1=10, 2=35, 3=55, 4=40}
//anagram
//String {Baba,x,Bonaba};       unquie letter only one
//groupBylength
li.stream().collect(Collectors.grouping(String::length));
//second largest from the list of string
//{10,15,8,49,1,12} start with 1
//1. Input: [1,2,[3,4],5,[6]]Output: [1,2,3,4,5,6]
//. Input: [1, 3, 11, 5]Output: 33
//(1,2,2,3,4,4,4,5,5) o/p: [1,2,3,4,5,null,null,null,null]
//List and List of int flatmap
asList.stream().flatMap(n->n.stream()).collect(Collectors.toList());
// List<String> words = Arrays.asList("Hello", "World", "Java", "Stream");   remove 1 and last char
List<String> collect = words.stream().filter(s->s.length()>2).map(n-> n.substring(1, n.length()-1)).collect(Collectors.toList());
<Binary Search (Divide and Conquer)>
//binary search algorithms  int[] arr = {10, 20, 30, 40, 50}; int key = 30;   O(log n) 
<Maximum Product of Three Arrays (Brute Force – 3 Nested Loops)>     
// randomly call 3 list of integer and multiply them
< Top K Frequent Elements (HashMap + Sorting / Heap)>
//[4,4,5,5,5,6,6,6] k=2 0/p:[5,6]           [10,10,20,20,20,30,30] k=2 o/p:[20,10]
< Longest Consecutive Sequence (Sorting + Linear Scan)>
// [100, 4, 200, 1, 3, 2]    o/p 4 seuence of a number [1,2,3,4,100,200]==>[1,2,3,4]==>count 4
<partioning 2 pointer>
//  in an array of +ve and -ve number make -ve numbers at start and + at end     int[] arr = {-1, 3, -2, 4, -5, 6};
<Zero 2 pointer>
//[4,0,3,-7,0,11,9,0]   o/p[0,0,0,4,3,-7,11,9]
// [1,0,2,3,0,0,4] o/p:[0, 0, 0, 1, 2, 3, 4]==> [1,2,3,4,0,0,0,0]
//An array of integers, e.g., [-2, 1, -3, 4, -1, 2, 1, -5, 4]  0/p An integer representing the maximum sum of a contiguous subarray 6 //(from subarray [4, -1, 2, 1])
##<greedy Multiple Transcation>
//Q1. Given an array prices[] of size n denoting the cost of stock on each day, the task is to find the maximum total profit if we can buy and sell the stocks any number of times.
//Note: We can only sell a stock which we have bought earlier and we cannot hold multiple stocks on any day.
//Input: prices[] = {100, 180, 260, 310, 40, 535, 695}    o/p::865
<greddy Single Transcation>
[Buy and sell stock//1. Input: prices = [7,1,5,3,6,4] Output: 5 that buying on day 2 and selling on day 1 is not allowed because '
you must buy before you sell.//2.Input: prices = [7,6,4,3,1]Output: 0 In this case, no transactions are done and the max profit = 0.]



private static void arr() {
// Best Time to Buy and Sell Stock (Single Transaction – Greedy)
		int[] prices= {7,1,5,3,6,4};  //5
		int min=Integer.MAX_VALUE;
		int max=0;
		for(int p:prices) {
			if(p<min) {
				min=p;}
			else {
				max=Math.max(max, p-min);}}
		System.out.println(max);

// Move Zeros to Beginning (Two Pointer Technique)
		int[] nums = {1,0,2,3,0,0,4};  //0001234
		int index=nums.length-1;
		for (int i = nums.length-1; i>=0; i--) {
			if(nums[i]!=0) {
				nums[index--]=nums[i];
			}
		}
		while(index>=0) {
			nums[index--]=0;
		}
		for(int n:nums) {
			System.out.print(n+" ");
		}

		System.out.println();

// Maximum Subarray Sum (Kadane’s Algorithm)
		int[] num = {-2, 1, -3, 4, -1, 2, 1, -5, 4};   //6
		int cs=num[0];
		int ms=num[0];
		for (int i = 1; i < num.length; i++) {
			cs=Math.max(num[i], cs+num[i]);
			ms=Math.max(ms, cs);
		}
		System.out.println(ms);


// Longest Consecutive Sequence (Sorting + Linear Scan)
		int se[]= {100, 4, 200, 1, 3, 2}; //o/p 4 seuence of a number [1,2,3,4,100,200]==>[1,2,3,4]==>count 4
		List<Integer> sl = Arrays.stream(se).distinct().sorted().boxed().collect(Collectors.toList());
		System.out.println(sl);
		int mc=1,cc=1;
		for (int i = 1; i < se.length; i++) {
			if(sl.get(i)==sl.get(i-1)+1) {
				cc++;}
			else {
				mc=Math.max(mc, cc);
				cc=1;
			}
		}
		//mc=Math.max(mc, cc);
		System.out.println(mc);


// Top K Frequent Elements (HashMap + Sorting / Heap)
		List<Integer> al = Arrays.asList(4,4,5,5,5,6,6,6);  //[5,6]
		Map<Integer, Long> collect = al.stream().collect(Collectors.groupingBy(Function.identity(),Collectors.counting()));
		List<Integer> collect2 = collect.entrySet().stream().sorted((a,b)->b.getValue().compareTo(a.getValue())).limit(2).map(n->n.getKey()).collect(Collectors.toList());
		System.out.println(collect2);


// Maximum Product of Three Arrays (Brute Force – 3 Nested Loops)
		int a[]= {1,2,3};
		int b[]= {4,5,3};
		int c[]= {8,12,3};
		int maax=0;
		for(int x:a) {
			for(int y:b) {
				for(int z:c) {
					maax=Math.max(maax, x*y*z);
				}
			}
		}
		System.out.println(maax);

// Rearrange Array by Sign (Partitioning – Two Pointer)
		int[] arr = {-1, 3, -2, 4, -5, 6};  //-1 -5 -2 4 3 6 
		int i=0;
		int j=arr.length-1;
		while(i<=j) {
			if(arr[i]<0) {
				i++;
			}else if(arr[j]>0) {
				j--;
			}else {
				int temp=arr[i];
				arr[i]=arr[j];
				arr[j]=temp;
				i++;
				j--;		
			}
		}
		for(int ah:arr) {
			System.out.print(ah+" ");
		}

// Binary Search (Divide and Conquer)
		int[] ar = {10, 20, 30, 40, 50};
		int low=0;
		int high=ar.length-1;
		int k=40;
		while(low<=high) {
			int mid=(low+high)/2;
			if(ar[mid]==k) {
				System.out.println("got");	
				break;
			}else if(ar[mid]<k) {
				low=mid+1;
			}else {
				high=mid-1;
			}
		}

// Best Time to Buy and Sell Stock II (Multiple Transactions – Greedy)
		int pricee[] = {100, 180, 260, 310, 40, 535, 695};
		int maxx=0;
		for (int l = 1; l < pricee.length; l++) {
			if(pricee[l]>pricee[l-1]) {
				maxx+=pricee[l]-pricee[l-1];
			}
		}
		System.out.println(maxx);




List<String> ls = Arrays.asList("Riya","k","Ho","kkk","hepp","loo","Baba","Banaba","olo","oh","40.0","Ho","loo");
		List<Integer> li = Arrays.asList(1,2,32,12,12);
		List<Integer> li1 = Arrays.asList(1,12,62,12);
		ArrayList<Integer> li2 = new ArrayList<>(li1);

		//second largest in string and Integer
		li.stream().distinct().sorted(Comparator.reverseOrder()).skip(1).limit(1).forEach(System.out::println);
		ls.stream().distinct().sorted(Comparator.comparing(String::length).reversed()).skip(1).limit(1).forEach(System.out::println);

		//first repeated and non repeated element and frequency
		Map<String, Long> map2 = ls.stream().collect(Collectors.groupingBy(Function.identity(),LinkedHashMap::new,Collectors.counting()));
		List<String> nrs = map2.entrySet().stream().filter(n->n.getValue()==1).map(n->n.getKey()+"="+n.getValue()).limit(1).collect(Collectors.toList());
		List<String> rs = map2.entrySet().stream().filter(n->n.getValue()>1).map(n->n.getKey()+"="+n.getValue()).limit(1).collect(Collectors.toList());
		System.out.println(rs);

		//repeated and non repeated element and frequency
		Map<Integer, Long> map1 = li.stream().collect(Collectors.groupingBy(Function.identity(),Collectors.counting()));
		List<String> collect15 = map1.entrySet().stream().filter(n->n.getValue()==1).map(n->n.getKey()+"="+n.getValue()).collect(Collectors.toList());
		List<String> collect16 = map1.entrySet().stream().filter(n->n.getValue()>1).map(n->n.getKey()+"="+n.getValue()).collect(Collectors.toList());
		//index of non repeated and repeated element
		for (int i = 0; i < li.size(); i++) {
			//			if(map1.get(li.get(i))==1) {
			//				System.out.println("Index of nonrepeated element:: "+i);
			//			}
			if(map1.get(li.get(i))>1) {
				System.out.println("Index of repeated element:: "+i);
			}
		}
		System.out.println(collect15);


		//binarynumber
		List<String> collect13 = ls.stream().filter(n->{
			try {
				Double.parseDouble(n);
				return n.contains(".");
				//				Integer.parseInt(n);
				//				return true;
			}catch (Exception e) {	
				return false;
				//return false;
			}
		}).collect(Collectors.toList());
		System.out.println(collect13);

		//sortbychar or  groupbychar
		List<String> collect11 = ls.stream().sorted(Comparator.comparing(s->s.charAt(0))).collect(Collectors.toList());
		Map<Character, List<String>> collect12 = ls.stream().collect(Collectors.groupingBy(s->s.charAt(0)));
		System.out.println(collect12);


		//Basic
		double orElse = li.stream().filter(n->n>10).mapToInt(n->n).average().orElse(0);
		Integer integer = li.stream().map(n->n*n).reduce((a,b)->a+b).get();
		List<Integer> collect9 = li.stream().filter(n->n%2==0).map(n->n*3).collect(Collectors.toList());

		//sum and mul
		li.stream().reduce((a,b)->a+b).get();
		li.stream().reduce((a,b)->a*b).get();
		//merege 2 array
		li2.addAll(li);
		//check ywo array equal sort
		//		li.equals(li2);
		//		Collections.sort(li);
		//		Collections.reverse(li);
		List<Integer> collect10 = li2.stream().distinct().collect(Collectors.toList());
		System.out.println(collect10);

		//TreeMap
		TreeMap<Integer, Integer> t1 = new TreeMap<>();
		t1.put(1, 10);
		t1.put(2, 20);
		t1.put(3, 30);
		TreeMap<Integer, Integer> t2 = new TreeMap<>();
		t2.put(1, 10);
		t2.put(2, 20);
		t2.put(4, 30);
		TreeMap<Integer, Integer> t3 = new TreeMap<>(t2);
		for(Entry<Integer, Integer> j:t1.entrySet()) {
			t3.merge(j.getKey(), j.getValue(), Integer::sum);
		}
		System.out.println(t3);

		//anagram
		Map<String, List<String>> map=new HashMap<>();
		for(String g:ls) {
			char[] c = g.toLowerCase().toCharArray();
			Arrays.sort(c);
			String s=new String(c);
			map.computeIfAbsent(s, n->new ArrayList<>()).add(g);
		}
		System.out.println(map.values());

		//Unquien letter from each word
		for(String d:ls) {
			Map<Character, Long> collect = d.toLowerCase().chars().mapToObj(c->(char)c).collect(Collectors.groupingBy(Function.identity(),Collectors.counting()));
			long count = collect.entrySet().stream().filter(n->n.getValue()==1).count();
			if(count==1) {
				System.out.println(d);
			}
		}

		//groupBylength
		Map<Integer, List<String>> collect8 = ls.stream().collect(Collectors.groupingBy(String::length));
		System.out.println(collect8);

		//second largest string int
		List<String> sll = ls.stream().sorted(Comparator.comparing(String::length).reversed()).skip(1).limit(1).collect(Collectors.toList());
		System.out.println(sll);
		List<Integer> collect7 = li.stream().sorted(Comparator.reverseOrder()).skip(1).limit(1).collect(Collectors.toList());
		System.out.println(collect7);

		//starts with 1
		List<Integer> asList3 = Arrays.asList(10,15,8,49,1,12);
		List<Integer> collect6 = asList3.stream().filter(n->String.valueOf(n).startsWith("1")).collect(Collectors.toList());
		System.out.println(collect6);

		//priortityque
		int[] o= {1, 3, 11, 5};
		PriorityQueue<Integer> pq=new PriorityQueue<>();
		for(int aa:o) {
			pq.add(aa);
		}
		int total=0;
		while(pq.size()>1) {
			int a = pq.poll();
			int b = pq.poll();
			int sum=a+b;
			total+=sum;
			pq.add(sum);
		}
		System.out.println(total);


		//duplicate null
		List<Integer> asList2 = Arrays.asList(1,2,2,3,4,4,4,5,5);
		HashSet<Integer> seen = new HashSet<>();
		ArrayList<Integer> all = new ArrayList<>();
		for(int aa:asList2) {
			if(seen.contains(aa)) {
				all.add(null);
			}else {
				seen.add(aa);
				all.add(aa);
			}
		}
		List<Integer> collect5 = all.stream().sorted(Comparator.nullsLast(null)).collect(Collectors.toList());
		System.out.println(collect5);


		//flat map
		List<List<Integer>> asList = Arrays.asList(Arrays.asList(1,2),Arrays.asList(3,4));
		List<Integer> collect4 = asList.stream().flatMap(n->n.stream()).collect(Collectors.toList());
		System.out.println(collect4);

		//remove 1 and remove last
		List<String> words = Arrays.asList("Hello", "World", "Java", "Stream");
		List<String> collect3 = words.stream().filter(n->n.length()>2).map(n->n.substring(1, n.length()-1)).collect(Collectors.toList());
		System.out.println(collect3);

	}
